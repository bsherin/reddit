{
    "sourceFile": "snapshot_and_score/create_snapshot_models.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1730149450638,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1730150181496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,12 +125,13 @@\n         good_users = good_users[good_users[\"top_level_comments\"] >= self.min_user_posts]\n         return good_users.index.tolist()\n     \n     def create_month_model(self, df, month, year):\n-        if self.use_run_number_as_seed:\n-            return group.sample(n=self.posts_per_user, random_state=self.run_number)\n-        else:\n-            return group.sample(n=self.posts_per_user)\n+        def select_random_posts(group):\n+            if self.use_run_number_as_seed:\n+                return group.sample(n=self.posts_per_user, random_state=self.run_number)\n+            else:\n+                return group.sample(n=self.posts_per_user)\n         try:\n             self.dstable(f\"Getting posts for month {month} year {year}\")\n             df['author'] = df['author'].astype(str)\n             \n@@ -153,13 +154,10 @@\n                 return {\"success\": False, \"reason\": \"nusers less than min_users_per_month\", \"month\": month, \"year\": year}\n             if len(candidate_users) < self.users_per_month:\n                 self.month_table[-1][\"success\"] = False\n                 return {\"success\": False, \"reason\": f\"candidate users {len(candidate_users)} less than users per month {self.users_per_month}\", \"month\": month, \"year\": year}\n-            if self.use_random_seed:\n-                true_seed = uuid.uuid4().int\n-                random.seed(true_seed)\n-            else:\n-                random.seed(self.seed)\n+            if self.use_run_number_as_seed:\n+                random.seed(self.run_number)\n             selected_users = random.sample(culist, self.users_per_month)\n             user_filtered_df = month_df[month_df['author'].isin(selected_users)]\n             random_posts = user_filtered_df.groupby(\"author\").apply(select_random_posts).reset_index(drop=True)\n             if \"post_id\" in random_posts.columns:\n"
                },
                {
                    "date": 1730150620395,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -155,9 +155,12 @@\n             if len(candidate_users) < self.users_per_month:\n                 self.month_table[-1][\"success\"] = False\n                 return {\"success\": False, \"reason\": f\"candidate users {len(candidate_users)} less than users per month {self.users_per_month}\", \"month\": month, \"year\": year}\n             if self.use_run_number_as_seed:\n+                print(\"using run number as seed\")\n                 random.seed(self.run_number)\n+            else:\n+                print(\"not using run number as seed\")\n             selected_users = random.sample(culist, self.users_per_month)\n             user_filtered_df = month_df[month_df['author'].isin(selected_users)]\n             random_posts = user_filtered_df.groupby(\"author\").apply(select_random_posts).reset_index(drop=True)\n             if \"post_id\" in random_posts.columns:\n"
                },
                {
                    "date": 1730150629685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -158,9 +158,9 @@\n             if self.use_run_number_as_seed:\n                 print(\"using run number as seed\")\n                 random.seed(self.run_number)\n             else:\n-                print(\"not using run number as seed\")\n+                print(\"using random seed\")\n             selected_users = random.sample(culist, self.users_per_month)\n             user_filtered_df = month_df[month_df['author'].isin(selected_users)]\n             random_posts = user_filtered_df.groupby(\"author\").apply(select_random_posts).reset_index(drop=True)\n             if \"post_id\" in random_posts.columns:\n"
                },
                {
                    "date": 1731371212715,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,316 @@\n+### This script is used to create language models for each month in the corpus. \n+# The language models are created using the KatzBigramLM class from the katz_class.py file. \n+# The language models are saved in a folder named \"snapshots\" in the output location.\n+# The script also saves a list of the post ids used to create the language models in a file named \"used_posts.pkl\" in the output location. \n+# The script saves a list of dictionaries containing information about the language models created for each month in a file named \"month_table.pkl\" in the output location. \n+# The script saves the start and end month and year of the longest sequence of months for which language models were successfully created in a file named \"parameters.txt\" in the output location.\n+\n+print(\"starting create_snapshot_models.py\")\n+import pickle\n+import json\n+import sys\n+import os\n+import traceback\n+import pandas as pd\n+import random\n+from katz_class import KatzBigramLM\n+\n+CORPUS_START_YEAR = 2006\n+CORPUS_START_MONTH = 5\n+CORPUS_END_YEAR = 2022\n+CORPUS_END_MONTH = 12\n+\n+\n+CORPUS_START = pd.Timestamp(year=CORPUS_START_YEAR, month=CORPUS_START_MONTH, day=1)\n+CORPUS_END = pd.Timestamp(year=CORPUS_END_YEAR, month=CORPUS_END_MONTH, day=31)\n+\n+month_list = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\",\n+             \"September\", \"October\", \"November\", \"December\"]\n+\n+def month_number(month_name):\n+    return month_list.index(month_name) + 1\n+\n+def handle_exception(ex, special_string=None):\n+    error_string = get_traceback_message(ex, special_string)\n+    print(error_string)\n+    return error_string\n+\n+def get_traceback_message(e, special_string=None):\n+    if special_string is None:\n+        template = \"<pre>An exception of type {0} occured. Arguments:\\n{1!r}\\n\"\n+    else:\n+        template = special_string + \"<pre>\\n\" + \"An exception of type {0} occurred. Arguments:\\n{1!r}\\n\"\n+    error_string = template.format(type(e).__name__, e.args)\n+    error_string += traceback.format_exc() + \"</pre>\"\n+    return error_string\n+\n+def load_pickle_or_parquet(path):\n+    fname, ext = os.path.splitext(path)\n+    if ext == \".parquet\":\n+        return pd.read_parquet(path)\n+    else:\n+        return pd.read_pickle(path)\n+\n+def find_longest_true_sequence(bool_list):\n+    current_start = None\n+    current_length = 0\n+    max_start = None\n+    max_length = 0\n+    \n+    for i, value in enumerate(bool_list):\n+        if value:\n+            if current_start is None:\n+                current_start = i  # Start a new sequence\n+            current_length += 1\n+        else:\n+            if current_start is not None:\n+                if current_length > max_length:  # Check if the current sequence is the longest\n+                    max_length = current_length\n+                    max_start = current_start\n+                # Reset current sequence\n+                current_start = None\n+                current_length = 0\n+    \n+    # Handling the case where the list ends with True\n+    if current_start is not None and current_length > max_length:\n+        max_length = current_length\n+        max_start = current_start\n+    \n+    # Calculating the end index of the longest sequence\n+    max_end = None\n+    if max_start is not None:\n+        max_end = max_start + max_length - 1\n+    \n+    return (max_start, max_end)\n+\n+\n+def ds(txt):\n+    print(txt)\n+\n+print(\"done with globals\")\n+params = [\"run_number\", \"use_run_number_as_seed\", \"users_per_month\", \"posts_per_user\", \"truncate_text\", \"max_len\",\n+          \"start_buffer\", \"end_buffer\", \"min_user_posts\", \"leave_unknown\", \"max_discount\"]\n+\n+class LmSnapshotAuto():\n+    def __init__(self, jsonfile, subreddit, base_path, uid, run_number):\n+        self.uid = uid\n+        self.subreddit_name = subreddit\n+        self.working_directory = f\"{base_path}/{self.subreddit_name}\"\n+\n+        with open(jsonfile, 'r') as file:\n+            config = json.load(file)\n+\n+        for param in params:\n+            if param in config:\n+                setattr(self, param, config[param])\n+            else:\n+                setattr(self, param, None)\n+        \n+        self.run_number = int(run_number)\n+        self.df_file = f\"{self.working_directory}/{self.subreddit_name}_df_true.parquet\"\n+        self.user_df_file = f\"{self.working_directory}/{self.subreddit_name}_user_data.parquet\"\n+        self.output_location = self.working_directory\n+        self.output_folder_name = f\"{self.subreddit_name}_snapshots\"\n+\n+        return\n+\n+    def display_status(self, text):\n+        print(text)\n+\n+    def html_table(self, text):\n+        print(text)\n+\n+    def dstable(self, txt):\n+        print(txt)\n+\n+    def modify_options(self):\n+        return self.options\n+    \n+    def get_good_users(self, user_df):\n+        good_users = user_df\n+        good_users[\"total_posts\"] = good_users.apply(lambda row: row[\"top_level_comments\"] + row[\"submissions\"], 1)\n+        good_users = good_users[good_users[\"top_level_comments\"] >= self.min_user_posts]\n+        return good_users.index.tolist()\n+    \n+    def create_month_model(self, df, month, year):\n+        def select_random_posts(group):\n+            if self.use_run_number_as_seed:\n+                return group.sample(n=self.posts_per_user, random_state=self.run_number)\n+            else:\n+                return group.sample(n=self.posts_per_user)\n+        try:\n+            self.dstable(f\"Getting posts for month {month} year {year}\")\n+            df['author'] = df['author'].astype(str)\n+            \n+            month_df = df[(df['true_date'].dt.year == year) & (df['true_date'].dt.month == month)]\n+            post_counts = month_df.groupby('author').size()\n+            users = month_df.author.unique()\n+            candidate_users = post_counts[post_counts >= self.posts_per_user]\n+            self.month_table.append({\n+                \"month\": month, \"year\": year, \"nposts\": len(month_df), \"nusers\": len(users), \n+                \"cand_users\": len(candidate_users), \"success\": \"pending\"\n+            })\n+            # we assign status_stub because KatzBigramLM looks for it\n+            self.dstable(f\"Getting posts for month {month} year {year}\")\n+            culist = list(candidate_users.keys())\n+            if len(month_df) < self.min_posts_per_month:\n+                self.month_table[-1][\"success\"] = False\n+                return {\"success\": False, \"reason\": \"too few posts\", \"month\": month, \"year\": year}\n+            if len(users) < self.min_users_per_month:\n+                self.month_table[-1][\"success\"] = False\n+                return {\"success\": False, \"reason\": \"nusers less than min_users_per_month\", \"month\": month, \"year\": year}\n+            if len(candidate_users) < self.users_per_month:\n+                self.month_table[-1][\"success\"] = False\n+                return {\"success\": False, \"reason\": f\"candidate users {len(candidate_users)} less than users per month {self.users_per_month}\", \"month\": month, \"year\": year}\n+            if self.use_run_number_as_seed:\n+                print(\"using run number as seed\")\n+                random.seed(self.run_number)\n+            else:\n+                print(\"using random seed\")\n+            selected_users = random.sample(culist, self.users_per_month)\n+            user_filtered_df = month_df[month_df['author'].isin(selected_users)]\n+            random_posts = user_filtered_df.groupby(\"author\").apply(select_random_posts).reset_index(drop=True)\n+            if \"post_id\" in random_posts.columns:\n+                post_ids = random_posts.post_id.tolist()\n+            else:\n+                post_ids = random_posts.index.tolist()\n+            self.dstable(f\"building language model for month {month} year {year}\")\n+            lm = KatzBigramLM(leave_unknown=self.leave_unknown, \n+                              max_discount=self.max_discount\n+                              )\n+            lm.fit(random_posts)\n+            self.month_table[-1][\"success\"] = True\n+            return {\"success\": True, \"month\": month, \"year\": year, \"lm_dict\": lm.__getstate__(), \"post_ids\": post_ids}\n+        except Exception as ex:\n+            self.month_table[-1][\"success\"] = False\n+            return {\"success\": False, \"reason\": handle_exception(ex), \"month\": month, \"year\": year}\n+    \n+    def get_parameters(self):\n+        plist = []\n+        plist.append({\"name\": \"uid\", \"value\": self.uid})\n+\n+        for param in params:\n+            if hasattr(self, param):\n+                plist.append({\"name\": param, \"value\": getattr(self, param)})\n+\n+        plist += [\n+            {\"name\": \"start_month\", \"value\": self.start_month},\n+            {\"name\": \"start_year\", \"value\": self.start_year},\n+            {\"name\": \"end_month\", \"value\": self.end_month},\n+            {\"name\": \"end_year\", \"value\": self.end_year}\n+        ]\n+        return plist\n+    \n+    def get_param_string(self):\n+        plist = self.get_parameters()\n+        pstr = \"\"\n+        for p in plist:\n+            pstr += f\"{p['name']}:\\t{str(p['value'])}\\n\"\n+        return pstr\n+    \n+    def render_content(self):\n+        class BreakLoops(Exception): \n+            pass\n+        \n+        self.min_users_per_month = self.users_per_month * 2\n+        self.min_posts_per_month = self.posts_per_user * self.min_users_per_month \n+        \n+        self.month_table = []\n+        self.status_stub = \"\"\n+        \n+        output_path = f\"{self.output_location}/{self.output_folder_name}_{self.uid}\"\n+        snapshot_path = f\"{output_path}/snapshots\"\n+        print(f\"creating snapshot folder {snapshot_path}\")\n+        os.makedirs(snapshot_path)\n+            \n+        print(\"reading data\")\n+        \n+        df = load_pickle_or_parquet(self.df_file)\n+        user_df = load_pickle_or_parquet(self.user_df_file)\n+        \n+        first_date = user_df.first_post.min()\n+        \n+        start_buffer_td = pd.Timedelta(weeks=(self.start_buffer * 4))\n+        end_buffer_td = pd.Timedelta(weeks=(self.end_buffer * 4))\n+        \n+        if first_date < CORPUS_START + start_buffer_td:\n+            first_date = CORPUS_START + start_buffer_td\n+            \n+        if first_date.month == 12:\n+            start_month = 1\n+            start_year = int(first_date.year + 1)\n+        else:\n+            start_month =int(first_date.month + 1)\n+            start_year = int(first_date.year)\n+        \n+        end_date = CORPUS_END - end_buffer_td\n+        \n+        if end_date.month == 1:\n+            end_month = 12\n+            end_year = end_date.year - 1\n+        else:\n+            end_month = end_date.month - 1\n+            end_year = end_date.year\n+        \n+        ds(\"pruning users\")\n+        if self.min_user_posts > 1:\n+            good_user_list = self.get_good_users(user_df)\n+            df = df[df['author'].isin(good_user_list)]\n+        \n+        ds(\"building models\")\n+        result = None\n+        all_used_posts = []\n+        success_list = []\n+        try:\n+            for year in range(start_year, end_year + 1):\n+                if year == start_year:\n+                    smonth = start_month\n+                else:\n+                    smonth = 1\n+                for month in range(smonth, 13):\n+                    if year == end_year and month > end_month:\n+                        break\n+                    result = None\n+                    result = self.create_month_model(df, month, year)\n+                    mstring = f\"{month_list[month - 1]}-{str(year)}\"\n+                    if result[\"success\"]:\n+                        success_list.append([month, year, True])\n+                        all_used_posts.append(result[\"post_ids\"])\n+                        self.dstable(f\"successfully created model for month {month} year {year}\")\n+                        fpath = f\"{snapshot_path}/{mstring}\"\n+                        with open(fpath, \"wb\") as f:\n+                            pickle.dump(result, f)\n+                    else:\n+                        success_list.append([month, year, False])\n+                        ostring = f\"failed for month {month} year {year} reason {result['reason']}\"\n+                        print(ostring)\n+                        self.dstable(ostring)\n+         \n+            used_path = f\"{output_path}/used_posts.pkl\"\n+            with open(used_path, \"wb\") as f:\n+                pickle.dump(all_used_posts, f)\n+            table_path = f\"{output_path}/month_table.pkl\"\n+            with open(table_path, \"wb\") as f:\n+                pickle.dump(self.month_table, f)\n+        \n+            bool_list = [suc[2] for suc in success_list]\n+            sindex, eindex = find_longest_true_sequence(bool_list)\n+            self.start_month = success_list[sindex][0]\n+            self.start_year = success_list[sindex][1]\n+            self.end_month = success_list[eindex][0]\n+            self.end_year = success_list[eindex][1]\n+            edate = success_list[eindex]\n+            with open(f\"{output_path}/parameters.txt\", \"w\") as f:\n+                f.write(self.get_param_string())\n+        except BreakLoops:\n+            if result is not None and \"reason\" in result:\n+                reason = result[\"reason\"]\n+            else:\n+                reason = \"none\"\n+            return f\"failed in month {month} of year {year} with reason {reason}\"\n+\n+if __name__ == '__main__':\n+    print(\"starting\")\n+    print(\"got args \" + str(sys.argv))\n+    Tile = LmSnapshotAuto(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5])\n+    Tile.render_content()\n\\ No newline at end of file\n"
                }
            ],
            "date": 1730149450638,
            "name": "Commit-0",
            "content": "print(\"starting create_snapshot_models.py\")\nimport pickle\nimport json\nimport sys\nimport os\nimport traceback\nimport pandas as pd\nimport random\nfrom katz_class import KatzBigramLM\n\nCORPUS_START_YEAR = 2006\nCORPUS_START_MONTH = 5\nCORPUS_END_YEAR = 2022\nCORPUS_END_MONTH = 12\n\n\nCORPUS_START = pd.Timestamp(year=CORPUS_START_YEAR, month=CORPUS_START_MONTH, day=1)\nCORPUS_END = pd.Timestamp(year=CORPUS_END_YEAR, month=CORPUS_END_MONTH, day=31)\n\nmonth_list = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\",\n             \"September\", \"October\", \"November\", \"December\"]\n\ndef month_number(month_name):\n    return month_list.index(month_name) + 1\n\ndef handle_exception(ex, special_string=None):\n    error_string = get_traceback_message(ex, special_string)\n    print(error_string)\n    return error_string\n\ndef get_traceback_message(e, special_string=None):\n    if special_string is None:\n        template = \"<pre>An exception of type {0} occured. Arguments:\\n{1!r}\\n\"\n    else:\n        template = special_string + \"<pre>\\n\" + \"An exception of type {0} occurred. Arguments:\\n{1!r}\\n\"\n    error_string = template.format(type(e).__name__, e.args)\n    error_string += traceback.format_exc() + \"</pre>\"\n    return error_string\n\ndef load_pickle_or_parquet(path):\n    fname, ext = os.path.splitext(path)\n    if ext == \".parquet\":\n        return pd.read_parquet(path)\n    else:\n        return pd.read_pickle(path)\n\ndef find_longest_true_sequence(bool_list):\n    current_start = None\n    current_length = 0\n    max_start = None\n    max_length = 0\n    \n    for i, value in enumerate(bool_list):\n        if value:\n            if current_start is None:\n                current_start = i  # Start a new sequence\n            current_length += 1\n        else:\n            if current_start is not None:\n                if current_length > max_length:  # Check if the current sequence is the longest\n                    max_length = current_length\n                    max_start = current_start\n                # Reset current sequence\n                current_start = None\n                current_length = 0\n    \n    # Handling the case where the list ends with True\n    if current_start is not None and current_length > max_length:\n        max_length = current_length\n        max_start = current_start\n    \n    # Calculating the end index of the longest sequence\n    max_end = None\n    if max_start is not None:\n        max_end = max_start + max_length - 1\n    \n    return (max_start, max_end)\n\n\ndef ds(txt):\n    print(txt)\n\nprint(\"done with globals\")\nparams = [\"run_number\", \"use_run_number_as_seed\", \"users_per_month\", \"posts_per_user\", \"truncate_text\", \"max_len\",\n          \"start_buffer\", \"end_buffer\", \"min_user_posts\", \"leave_unknown\", \"max_discount\"]\n\nclass LmSnapshotAuto():\n    def __init__(self, jsonfile, subreddit, base_path, uid, run_number):\n        self.uid = uid\n        self.subreddit_name = subreddit\n        self.working_directory = f\"{base_path}/{self.subreddit_name}\"\n\n        with open(jsonfile, 'r') as file:\n            config = json.load(file)\n\n        for param in params:\n            if param in config:\n                setattr(self, param, config[param])\n            else:\n                setattr(self, param, None)\n        \n        self.run_number = int(run_number)\n        self.df_file = f\"{self.working_directory}/{self.subreddit_name}_df_true.parquet\"\n        self.user_df_file = f\"{self.working_directory}/{self.subreddit_name}_user_data.parquet\"\n        self.output_location = self.working_directory\n        self.output_folder_name = f\"{self.subreddit_name}_snapshots\"\n\n        return\n\n    def display_status(self, text):\n        print(text)\n\n    def html_table(self, text):\n        print(text)\n\n    def dstable(self, txt):\n        print(txt)\n\n    def modify_options(self):\n        return self.options\n    \n    def get_good_users(self, user_df):\n        good_users = user_df\n        good_users[\"total_posts\"] = good_users.apply(lambda row: row[\"top_level_comments\"] + row[\"submissions\"], 1)\n        good_users = good_users[good_users[\"top_level_comments\"] >= self.min_user_posts]\n        return good_users.index.tolist()\n    \n    def create_month_model(self, df, month, year):\n        if self.use_run_number_as_seed:\n            return group.sample(n=self.posts_per_user, random_state=self.run_number)\n        else:\n            return group.sample(n=self.posts_per_user)\n        try:\n            self.dstable(f\"Getting posts for month {month} year {year}\")\n            df['author'] = df['author'].astype(str)\n            \n            month_df = df[(df['true_date'].dt.year == year) & (df['true_date'].dt.month == month)]\n            post_counts = month_df.groupby('author').size()\n            users = month_df.author.unique()\n            candidate_users = post_counts[post_counts >= self.posts_per_user]\n            self.month_table.append({\n                \"month\": month, \"year\": year, \"nposts\": len(month_df), \"nusers\": len(users), \n                \"cand_users\": len(candidate_users), \"success\": \"pending\"\n            })\n            # we assign status_stub because KatzBigramLM looks for it\n            self.dstable(f\"Getting posts for month {month} year {year}\")\n            culist = list(candidate_users.keys())\n            if len(month_df) < self.min_posts_per_month:\n                self.month_table[-1][\"success\"] = False\n                return {\"success\": False, \"reason\": \"too few posts\", \"month\": month, \"year\": year}\n            if len(users) < self.min_users_per_month:\n                self.month_table[-1][\"success\"] = False\n                return {\"success\": False, \"reason\": \"nusers less than min_users_per_month\", \"month\": month, \"year\": year}\n            if len(candidate_users) < self.users_per_month:\n                self.month_table[-1][\"success\"] = False\n                return {\"success\": False, \"reason\": f\"candidate users {len(candidate_users)} less than users per month {self.users_per_month}\", \"month\": month, \"year\": year}\n            if self.use_random_seed:\n                true_seed = uuid.uuid4().int\n                random.seed(true_seed)\n            else:\n                random.seed(self.seed)\n            selected_users = random.sample(culist, self.users_per_month)\n            user_filtered_df = month_df[month_df['author'].isin(selected_users)]\n            random_posts = user_filtered_df.groupby(\"author\").apply(select_random_posts).reset_index(drop=True)\n            if \"post_id\" in random_posts.columns:\n                post_ids = random_posts.post_id.tolist()\n            else:\n                post_ids = random_posts.index.tolist()\n            self.dstable(f\"building language model for month {month} year {year}\")\n            lm = KatzBigramLM(leave_unknown=self.leave_unknown, \n                              max_discount=self.max_discount\n                              )\n            lm.fit(random_posts)\n            self.month_table[-1][\"success\"] = True\n            return {\"success\": True, \"month\": month, \"year\": year, \"lm_dict\": lm.__getstate__(), \"post_ids\": post_ids}\n        except Exception as ex:\n            self.month_table[-1][\"success\"] = False\n            return {\"success\": False, \"reason\": handle_exception(ex), \"month\": month, \"year\": year}\n    \n    def get_parameters(self):\n        plist = []\n        plist.append({\"name\": \"uid\", \"value\": self.uid})\n\n        for param in params:\n            if hasattr(self, param):\n                plist.append({\"name\": param, \"value\": getattr(self, param)})\n\n        plist += [\n            {\"name\": \"start_month\", \"value\": self.start_month},\n            {\"name\": \"start_year\", \"value\": self.start_year},\n            {\"name\": \"end_month\", \"value\": self.end_month},\n            {\"name\": \"end_year\", \"value\": self.end_year}\n        ]\n        return plist\n    \n    def get_param_string(self):\n        plist = self.get_parameters()\n        pstr = \"\"\n        for p in plist:\n            pstr += f\"{p['name']}:\\t{str(p['value'])}\\n\"\n        return pstr\n    \n    def render_content(self):\n        class BreakLoops(Exception): \n            pass\n        \n        self.min_users_per_month = self.users_per_month * 2\n        self.min_posts_per_month = self.posts_per_user * self.min_users_per_month \n        \n        self.month_table = []\n        self.status_stub = \"\"\n        \n        output_path = f\"{self.output_location}/{self.output_folder_name}_{self.uid}\"\n        snapshot_path = f\"{output_path}/snapshots\"\n        print(f\"creating snapshot folder {snapshot_path}\")\n        os.makedirs(snapshot_path)\n            \n        print(\"reading data\")\n        \n        df = load_pickle_or_parquet(self.df_file)\n        user_df = load_pickle_or_parquet(self.user_df_file)\n        \n        first_date = user_df.first_post.min()\n        \n        start_buffer_td = pd.Timedelta(weeks=(self.start_buffer * 4))\n        end_buffer_td = pd.Timedelta(weeks=(self.end_buffer * 4))\n        \n        if first_date < CORPUS_START + start_buffer_td:\n            first_date = CORPUS_START + start_buffer_td\n            \n        if first_date.month == 12:\n            start_month = 1\n            start_year = int(first_date.year + 1)\n        else:\n            start_month =int(first_date.month + 1)\n            start_year = int(first_date.year)\n        \n        end_date = CORPUS_END - end_buffer_td\n        \n        if end_date.month == 1:\n            end_month = 12\n            end_year = end_date.year - 1\n        else:\n            end_month = end_date.month - 1\n            end_year = end_date.year\n        \n        ds(\"pruning users\")\n        if self.min_user_posts > 1:\n            good_user_list = self.get_good_users(user_df)\n            df = df[df['author'].isin(good_user_list)]\n        \n        ds(\"building models\")\n        result = None\n        all_used_posts = []\n        success_list = []\n        try:\n            for year in range(start_year, end_year + 1):\n                if year == start_year:\n                    smonth = start_month\n                else:\n                    smonth = 1\n                for month in range(smonth, 13):\n                    if year == end_year and month > end_month:\n                        break\n                    result = None\n                    result = self.create_month_model(df, month, year)\n                    mstring = f\"{month_list[month - 1]}-{str(year)}\"\n                    if result[\"success\"]:\n                        success_list.append([month, year, True])\n                        all_used_posts.append(result[\"post_ids\"])\n                        self.dstable(f\"successfully created model for month {month} year {year}\")\n                        fpath = f\"{snapshot_path}/{mstring}\"\n                        with open(fpath, \"wb\") as f:\n                            pickle.dump(result, f)\n                    else:\n                        success_list.append([month, year, False])\n                        ostring = f\"failed for month {month} year {year} reason {result['reason']}\"\n                        print(ostring)\n                        self.dstable(ostring)\n         \n            used_path = f\"{output_path}/used_posts.pkl\"\n            with open(used_path, \"wb\") as f:\n                pickle.dump(all_used_posts, f)\n            table_path = f\"{output_path}/month_table.pkl\"\n            with open(table_path, \"wb\") as f:\n                pickle.dump(self.month_table, f)\n        \n            bool_list = [suc[2] for suc in success_list]\n            sindex, eindex = find_longest_true_sequence(bool_list)\n            self.start_month = success_list[sindex][0]\n            self.start_year = success_list[sindex][1]\n            self.end_month = success_list[eindex][0]\n            self.end_year = success_list[eindex][1]\n            edate = success_list[eindex]\n            with open(f\"{output_path}/parameters.txt\", \"w\") as f:\n                f.write(self.get_param_string())\n        except BreakLoops:\n            if result is not None and \"reason\" in result:\n                reason = result[\"reason\"]\n            else:\n                reason = \"none\"\n            return f\"failed in month {month} of year {year} with reason {reason}\"\n\nif __name__ == '__main__':\n    print(\"starting\")\n    print(\"got args \" + str(sys.argv))\n    Tile = LmSnapshotAuto(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5])\n    Tile.render_content()"
        }
    ]
}